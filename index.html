<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <link rel="manifest" href="manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="连连看PWA">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>萌萌连连看</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom, etc. */
            overscroll-behavior-y: contain; /* Prevents pull-to-refresh on game area */
        }
        .game-wrapper {
            width: 100%;
            max-width: 600px; /* Max width for larger screens */
            margin: auto;
            padding: 1rem; /* Responsive padding */
        }
        .game-board {
            display: grid;
            grid-template-columns: repeat(10, 1fr); /* 10 columns */
            gap: 2px; /* Small gap between tiles */
            padding: 5px; /* Padding around the grid */
            background-color: #f0f0f0;
            border-radius: 8px;
            position: relative; /* For canvas positioning */
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            width: 100%; /* Ensure it takes full width of its container */
        }
        .tile {
            width: 100%; /* Make tile fill grid cell */
            aspect-ratio: 1 / 1; /* Maintain square shape */
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: clamp(14px, 4.5vw, 24px); /* Responsive font size */
            background-color: #fff5e1; /* Light creamy background */
            border: 1px solid #ffdda0; /* Light orange border */
            border-radius: 4px;
            cursor: pointer;
            transition: transform 0.1s ease, background-color 0.2s ease;
            user-select: none; /* Prevent text selection */
        }
        .tile:hover {
            transform: scale(1.05);
        }
        .tile.selected {
            background-color: #ffd699; /* Highlight color for selected tile */
            border-color: #ffc266;
            box-shadow: 0 0 8px rgba(255,165,0,0.5);
        }
        .tile.empty {
            background-color: transparent;
            border-color: transparent;
            cursor: default;
            pointer-events: none; /* Make empty tiles unclickable */
        }
        #line-canvas {
            position: absolute;
            top: 5px; /* Match game-board padding */
            left: 5px; /* Match game-board padding */
            width: calc(100% - 10px); /* Adjust for padding */
            height: calc(100% - 10px); /* Adjust for padding */
            pointer-events: none; /* Canvas doesn't block tile clicks */
            z-index: 10; /* Draw lines above tiles but below messages */
        }
        .info-bar span {
            min-width: 80px; /* Ensure consistent width for info items */
            text-align: center;
            font-size: clamp(0.8rem, 3vw, 1rem); /* Responsive font size */
        }
        button {
            padding: 0.6rem 1.2rem;
            border-radius: 0.5rem;
            font-size: clamp(0.9rem, 3.5vw, 1rem); /* Responsive font size */
            cursor: pointer;
        }

        /* Added Animation Styles */
        .tile.shaking {
            animation: shake 0.5s cubic-bezier(.36,.07,.19,.97) both;
            transform: translate3d(0, 0, 0); /* Hardware acceleration hint */
        }

        .tile.disappearing {
            animation: disappear 0.4s ease-out forwards;
        }

        @keyframes shake {
            10%, 90% {
                transform: translate3d(-1px, 0, 0) scale(1.02);
            }
            20%, 80% {
                transform: translate3d(2px, 0, 0) scale(1.02);
            }
            30%, 50%, 70% {
                transform: translate3d(-3px, 0, 0) scale(1.02);
            }
            40%, 60% {
                transform: translate3d(3px, 0, 0) scale(1.02);
            }
        }

        @keyframes disappear {
            0% {
                transform: scale(1) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: scale(0.3) rotate(45deg);
                opacity: 0;
            }
        }
        /* End of Added Animation Styles */


        /* Responsive adjustments for larger screens */
        @media (min-width: 600px) {
            .game-board {
                gap: 4px;
                padding: 10px;
            }
            #line-canvas {
                top: 10px;
                left: 10px;
                width: calc(100% - 20px);
                height: calc(100% - 20px);
            }
            .tile {
                font-size: clamp(16px, 4vw, 28px); /* Slightly larger font on bigger screens */
                border-radius: 6px;
            }
        }
    </style>
</head>
<body class="bg-gradient-to-br from-purple-400 via-pink-500 to-red-500 min-h-screen flex flex-col items-center justify-center p-0 sm:p-4">

    <div class="game-wrapper bg-white/90 p-4 sm:p-6 md:p-8 rounded-xl shadow-2xl w-full">
        <h1 class="text-2xl sm:text-3xl md:text-4xl font-bold text-center text-pink-600 mb-3 sm:mb-4">🌈 萌萌连连看 🌈</h1>

        <div class="info-bar flex flex-wrap justify-around items-center mb-3 sm:mb-4 text-gray-700 gap-1 sm:gap-2">
            <span class="bg-blue-100 p-1 sm:p-2 rounded-lg shadow">时间: <span id="time">0</span> 秒</span>
            <span class="bg-green-100 p-1 sm:p-2 rounded-lg shadow">得分: <span id="score">0</span></span>
            <span class="bg-yellow-100 p-1 sm:p-2 rounded-lg shadow">剩余: <span id="tiles-remaining">0</span></span>
        </div>

        <div id="game-container" class="relative w-full">
            <div id="game-board" class="game-board mx-auto">
                </div>
            <canvas id="line-canvas"></canvas>
        </div>

        <div class="controls mt-4 sm:mt-6 flex justify-center gap-4">
            <button id="new-game-btn" class="bg-pink-500 hover:bg-pink-600 text-white font-semibold py-2 px-4 sm:px-6 rounded-lg shadow-md transition duration-150">
                新游戏
            </button>
            <button id="toggle-bgm-btn" class="bg-blue-500 hover:bg-blue-600 text-white font-semibold py-2 px-4 sm:px-6 rounded-lg shadow-md transition duration-150">
                BGM: 开
            </button>
        </div>

        <div id="message-box" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50 hidden">
            <div class="bg-white p-6 sm:p-8 rounded-lg shadow-xl text-center max-w-xs mx-auto">
                <p id="message-text" class="text-lg sm:text-xl mb-4"></p>
                <button id="message-ok-btn" class="bg-pink-500 hover:bg-pink-600 text-white font-semibold py-2 px-6 rounded-lg">好的</button>
            </div>
        </div>
    </div>
    
    <!-- 
        BGM Audio Element. 
        NOTE: If you are running this HTML file directly from your local file system (e.g., file:///...), 
        browsers might block loading local audio files due to security restrictions (URL safety check).
        For reliable BGM playback during local development, serve this HTML and bgm.mp3 
        from a simple local web server (e.g., using Python's http.server or a VS Code Live Server extension).
    -->
    <audio id="bgm-audio" src="bgm.mp3" loop preload="auto"></audio>

    <script>
        // --- Game Configuration ---
        const GAME_ROWS = 8;
        const GAME_COLS = 10;
        const BOARD_ROWS = GAME_ROWS + 2; // For border/padding
        const BOARD_COLS = GAME_COLS + 2; // For border/padding
        const EMPTY_TILE = null;
        const EMOJIS_POOL = ["🐹", "🐶", "🐱", "🐭", "🦊", "🐻", "�", "🐨", "🐯", "🦁", "🐮", "🐷", "🐸", "🐵", "🐔", "🐧", "🐦", "🐤", "🦋", "🐛", "🐝", "🐞", "🐢", "🐍", "🐙", "🦑", "🦀", "🦞", "🐠", "🐬", "🐳", "🦈", "🦓", "🦒", "🐘", "🦏", "🦛", "🐐", "🐑", "🐖", "🦔", "🐿️", "🦘", "🦥", "🦦", "🦢", "🦜", "🦉", "🦚"];

        // --- Game State ---
        let board = [];
        let selectedTile = null;
        let score = 0;
        let time = 0;
        let timerInterval = null;
        let tilesRemaining = 0;
        let bgmEnabled = true; // User's preference for BGM
        let isProcessingMatch = false; // To prevent multiple actions during match processing

        // --- Web Audio API Setup (for sound effects) ---
        let audioCtx = null; // AudioContext for sound effects

        // Initialize AudioContext and BGM on first user interaction (click/touch)
        // This is crucial for browsers' autoplay policies.
        function initAudioAndBGM() { 
            if (!audioCtx && (window.AudioContext || window.webkitAudioContext)) {
                try {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    console.log("AudioContext for sound effects initialized by user interaction.");
                } catch (e) {
                    console.error("Web Audio API (for sound effects) is not supported in this browser.", e);
                }
            }

            // Try to play BGM if it's enabled and was paused (e.g., due to autoplay restrictions)
            if (bgmEnabled && bgmAudioElement && bgmAudioElement.paused) {
                console.log("Attempting to play BGM from initAudioAndBGM after user interaction.");
                playMp3BGM(); 
            }
        }
        document.body.addEventListener('click', initAudioAndBGM, { once: true });
        document.body.addEventListener('touchstart', initAudioAndBGM, { once: true });


        // --- DOM Elements ---
        const gameBoardElement = document.getElementById('game-board');
        const timeElement = document.getElementById('time');
        const scoreElement = document.getElementById('score');
        const tilesRemainingElement = document.getElementById('tiles-remaining');
        const newGameBtn = document.getElementById('new-game-btn');
        const toggleBGMBtn = document.getElementById('toggle-bgm-btn');
        const lineCanvas = document.getElementById('line-canvas');
        const canvasCtx = lineCanvas.getContext('2d');
        const messageBox = document.getElementById('message-box');
        const messageText = document.getElementById('message-text');
        const messageOkBtn = document.getElementById('message-ok-btn');
        const bgmAudioElement = document.getElementById('bgm-audio'); 
        
        // Set initial BGM volume and log BGM element status
        if (bgmAudioElement) {
            bgmAudioElement.volume = 0.2; // Set a softer volume for BGM
            console.log(`Initial BGM volume set to: ${bgmAudioElement.volume}`);
        }
        console.log("DOM Elements: BGM Audio Element:", bgmAudioElement, "Toggle BGM Button:", toggleBGMBtn);

        // Add event listeners for BGM audio element for debugging
        if (bgmAudioElement) {
            bgmAudioElement.addEventListener('loadedmetadata', () => {
                console.log(`BGM Event: loadedmetadata - Duration: ${bgmAudioElement.duration} seconds`);
            });
            bgmAudioElement.addEventListener('canplay', () => { console.log("BGM Event: canplay"); });
            bgmAudioElement.addEventListener('canplaythrough', () => { console.log("BGM Event: canplaythrough"); });
            bgmAudioElement.addEventListener('play', () => { console.log("BGM Event: play"); });
            bgmAudioElement.addEventListener('playing', () => { console.log("BGM Event: playing"); });
            bgmAudioElement.addEventListener('pause', () => { console.log("BGM Event: pause"); });
            bgmAudioElement.addEventListener('ended', () => { console.log("BGM Event: ended (loop should restart it)"); });
            bgmAudioElement.addEventListener('error', (e) => {
                console.error("BGM Event: error - An error occurred.");
                if (bgmAudioElement.error) console.error(`Error code: ${bgmAudioElement.error.code}, Message: ${bgmAudioElement.error.message}`);
                else console.error("BGM error object not available.", e);
            });
            bgmAudioElement.addEventListener('stalled', () => { console.warn("BGM Event: stalled"); });
            bgmAudioElement.addEventListener('suspend', () => { console.log("BGM Event: suspend (audio loading suspended)"); });
            bgmAudioElement.addEventListener('waiting', () => { console.log("BGM Event: waiting (playback paused due to temporary lack of data)"); });
        }

        // --- Sound Effects (using Web Audio API) ---
        function playSoundEffect(type, frequency, duration, volume = 0.1, freqEndTime = null, freqEndValue = null) {
            if (!audioCtx || !audioCtx.destination) return; // AudioContext not initialized or unusable
            const sfxVolume = 0.5; // Master volume for sound effects
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();
            oscillator.type = type; // 'sine', 'square', 'sawtooth', 'triangle'
            oscillator.frequency.setValueAtTime(frequency, audioCtx.currentTime);
            if (freqEndTime && freqEndValue) { // For pitch bend effects
                oscillator.frequency.exponentialRampToValueAtTime(freqEndValue, audioCtx.currentTime + freqEndTime);
            }
            gainNode.gain.setValueAtTime(sfxVolume * volume, audioCtx.currentTime); // Apply volume
            gainNode.gain.exponentialRampToValueAtTime(0.00001, audioCtx.currentTime + duration); // Fade out
            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);
            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + duration);
        }

        function playClickSound() { playSoundEffect('sine', 700, 0.08, 0.4); } // Short, high-pitched click
        function playMatchSound() { playSoundEffect('triangle', 520, 0.15, 0.5, 0.08, 900); } // Ascending tone for match
        function playWinSound() {
            if (!audioCtx) return; // AudioContext not initialized
            const freqs = [523.25, 659.25, 783.99, 1046.50]; // C5, E5, G5, C6 - a cheerful arpeggio
            freqs.forEach((freq, i) => {
                setTimeout(() => playSoundEffect('sine', freq, 0.15, 0.4), i * 120); // Staggered notes
            });
        }

        // --- MP3 Background Music Control ---
        function playMp3BGM(restart = false) {
            if (!bgmAudioElement) {
                console.error("Cannot play BGM: audio element not found.");
                return;
            }

            if (!bgmEnabled) { // If user has disabled BGM globally
                console.log("BGM play call skipped: BGM is disabled (bgmEnabled=false).");
                if (!bgmAudioElement.paused) { // If it was somehow playing, stop it
                    stopMp3BGM(); 
                }
                return;
            }

            if (restart) {
                bgmAudioElement.currentTime = 0;
                console.log("BGM restart requested: currentTime set to 0. Attempting to play.");
            }
            
            // Attempt to play if BGM is enabled and ( (restart was requested) OR (it's currently paused) )
            // Also check if document is visible, to avoid issues with background tab autoplay restrictions
            if (bgmEnabled && (restart || bgmAudioElement.paused) && !document.hidden) {
                const playPromise = bgmAudioElement.play();
                if (playPromise !== undefined) {
                    playPromise.then(() => {
                        console.log(`MP3 BGM ${restart ? '(re)started' : 'resumed'} successfully.`);
                    }).catch(error => {
                        // Autoplay was prevented. This is common. User interaction will enable it via initAudioAndBGM.
                        console.warn(`MP3 BGM ${restart ? '(re)start' : 'resume'} failed. This is often due to autoplay policies. Error:`, error);
                    });
                } else {
                     // Fallback for browsers that don't return a promise (older ones)
                     console.warn("bgmAudioElement.play() did not return a promise. Attempting play directly.");
                     // bgmAudioElement.play(); // This might throw an error if autoplay is blocked, already handled by catch if promise exists
                }
            } else if (bgmEnabled && !bgmAudioElement.paused && !restart) {
                 console.log("BGM play call skipped: BGM is already playing and restart not requested.");
            } else if (document.hidden) {
                console.log("BGM play call skipped: Document is hidden.");
            }
        }

        function stopMp3BGM() { 
            if (bgmAudioElement) {
                bgmAudioElement.pause();
                console.log("MP3 BGM stopped (pause() called).");
            } else {
                 console.error("Cannot stop BGM: audio element not found.");
            }
        }

        function updateBGMButton() {
            if (toggleBGMBtn) {
                toggleBGMBtn.textContent = `BGM: ${bgmEnabled ? '开' : '关'}`;
            } else {
                console.error("Cannot update BGM button text: toggleBGMBtn element not found.");
            }
        }
        
        // Event listener for the BGM toggle button
        if (toggleBGMBtn) { 
            toggleBGMBtn.addEventListener('click', () => {
                console.log("BGM button clicked. Current bgmEnabled state BEFORE toggle:", bgmEnabled);
                const wasEnabled = bgmEnabled; 
                bgmEnabled = !bgmEnabled; 
                console.log("bgmEnabled toggled. New state:", bgmEnabled);

                if (bgmEnabled) {
                    console.log("Calling playMp3BGM() from button click (BGM enabled). Restart if it was previously off: ", !wasEnabled);
                    playMp3BGM(!wasEnabled); // Play, and restart if it was just turned on
                } else {
                    console.log("Calling stopMp3BGM() from button click (BGM disabled).");
                    stopMp3BGM();
                }
                updateBGMButton(); 
                console.log("BGM button text updated after click.");
            });
        } else {
            console.error("Could not add event listener: toggleBGMBtn element not found.");
        }
        
        // --- Pathfinding Logic ---
        // Helper: Check if a cell is empty on the (padded) board
        function isCellEmptyOnBoard(r, c, targetBoard) {
            if (r < 0 || r >= BOARD_ROWS || c < 0 || c >= BOARD_COLS) return false; // Out of bounds
            if (!targetBoard[r]) return false; // Row doesn't exist (shouldn't happen with proper board init)
            return targetBoard[r][c] === EMPTY_TILE;
        }
        // Helper: Check if a straight line (horizontal or vertical) is clear between two points
        function isLineClearOnBoard(p1, p2, isHorizontal, targetBoard) {
            if (isHorizontal) {
                const r = p1.r; const minC = Math.min(p1.c, p2.c); const maxC = Math.max(p1.c, p2.c);
                for (let c = minC + 1; c < maxC; c++) if (!isCellEmptyOnBoard(r, c, targetBoard)) return false;
            } else { // Vertical
                const c = p1.c; const minR = Math.min(p1.r, p2.r); const maxR = Math.max(p1.r, p2.r);
                for (let r = minR + 1; r < maxR; r++) if (!isCellEmptyOnBoard(r, c, targetBoard)) return false;
            }
            return true;
        }
        // Main pathfinding function: checks for 0, 1, or 2 turns
        function findPathOnBoard(p1, p2, targetBoard) {
            if (p1.r === p2.r && p1.c === p2.c) return null; // Same tile
            if (p1.type !== p2.type) return null; // Different types

            // 0 turns (direct line)
            if (p1.r === p2.r && isLineClearOnBoard(p1, p2, true, targetBoard)) return [p1, p2];
            if (p1.c === p2.c && isLineClearOnBoard(p1, p2, false, targetBoard)) return [p1, p2];

            // 1 turn
            const corner1 = { r: p1.r, c: p2.c }; // Horizontal then Vertical
            if (isCellEmptyOnBoard(corner1.r, corner1.c, targetBoard) && isLineClearOnBoard(p1, corner1, true, targetBoard) && isLineClearOnBoard(corner1, p2, false, targetBoard)) return [p1, corner1, p2];
            const corner2 = { r: p2.r, c: p1.c }; // Vertical then Horizontal
            if (isCellEmptyOnBoard(corner2.r, corner2.c, targetBoard) && isLineClearOnBoard(p1, corner2, false, targetBoard) && isLineClearOnBoard(corner2, p2, true, targetBoard)) return [p1, corner2, p2];

            // 2 turns (iterating through all possible intermediate points on the padded board)
            // Check paths extending horizontally from p1 first
            for (let ci = 0; ci < BOARD_COLS; ci++) {
                const intermediateH = { r: p1.r, c: ci }; // Intermediate point on same row as p1
                if (!isCellEmptyOnBoard(intermediateH.r, intermediateH.c, targetBoard) && !(intermediateH.r === p2.r && intermediateH.c === p2.c)) continue; // Skip if not empty and not p2
                if (!isLineClearOnBoard(p1, intermediateH, true, targetBoard)) continue; // Path from p1 to intermediateH must be clear

                // Now try to connect intermediateH to p2 with one turn
                const cornerH_V = { r: intermediateH.r, c: p2.c }; // (p1.r, ci) -> (p1.r, p2.c) -> (p2.r, p2.c)
                if ((isCellEmptyOnBoard(cornerH_V.r, cornerH_V.c, targetBoard) || (cornerH_V.r === p2.r && cornerH_V.c === p2.c)) && 
                    isLineClearOnBoard(intermediateH, cornerH_V, true, targetBoard) && 
                    isLineClearOnBoard(cornerH_V, p2, false, targetBoard)) {
                    // Avoid redundant paths like p1 -> p1_col_p2_col -> p2 if intermediateH is on p1's column and cornerH_V is p1 (already covered by 1 turn)
                    if (!((intermediateH.r === p1.r && intermediateH.c === p1.c) && (cornerH_V.r === p1.r && cornerH_V.c === p2.c))) {
                         return [p1, intermediateH, cornerH_V, p2];
                    }
                }
                const cornerV_H = { r: p2.r, c: intermediateH.c }; // (p1.r, ci) -> (p2.r, ci) -> (p2.r, p2.c)
                 if ((isCellEmptyOnBoard(cornerV_H.r, cornerV_H.c, targetBoard) || (cornerV_H.r === p2.r && cornerV_H.c === p2.c)) && 
                    isLineClearOnBoard(intermediateH, cornerV_H, false, targetBoard) && 
                    isLineClearOnBoard(cornerV_H, p2, true, targetBoard)) {
                     if (!((intermediateH.c === p1.c && intermediateH.c === p2.c) && (cornerV_H.r === p2.r && cornerV_H.c === p1.c))) { // Avoid redundant paths
                        return [p1, intermediateH, cornerV_H, p2];
                     }
                }
            }
            // Check paths extending vertically from p1
            for (let ri = 0; ri < BOARD_ROWS; ri++) {
                const intermediateV = { r: ri, c: p1.c }; // Intermediate point on same col as p1
                if (!isCellEmptyOnBoard(intermediateV.r, intermediateV.c, targetBoard) && !(intermediateV.r === p2.r && intermediateV.c === p2.c)) continue;
                if (!isLineClearOnBoard(p1, intermediateV, false, targetBoard)) continue;

                const cornerH_V = { r: intermediateV.r, c: p2.c }; // (ri, p1.c) -> (ri, p2.c) -> (p2.r, p2.c)
                if ((isCellEmptyOnBoard(cornerH_V.r, cornerH_V.c, targetBoard) || (cornerH_V.r === p2.r && cornerH_V.c === p2.c)) && 
                    isLineClearOnBoard(intermediateV, cornerH_V, true, targetBoard) && 
                    isLineClearOnBoard(cornerH_V, p2, false, targetBoard)) {
                     if (!((intermediateV.r === p1.r && intermediateV.r === p2.r) && (cornerH_V.c === p1.c && cornerH_V.c === p2.c))) { // Avoid redundant paths
                        return [p1, intermediateV, cornerH_V, p2];
                     }
                }
                const cornerV_H = { r: p2.r, c: intermediateV.c }; // (ri, p1.c) -> (p2.r, p1.c) -> (p2.r, p2.c)
                if ((isCellEmptyOnBoard(cornerV_H.r, cornerV_H.c, targetBoard) || (cornerV_H.r === p2.r && cornerV_H.c === p2.c)) && 
                    isLineClearOnBoard(intermediateV, cornerV_H, false, targetBoard) && 
                    isLineClearOnBoard(cornerV_H, p2, true, targetBoard)) {
                     if (!((intermediateV.c === p1.c && intermediateV.c === p2.c) && (cornerV_H.r === p1.r && cornerV_H.r === p2.r))) { // Avoid redundant paths
                        return [p1, intermediateV, cornerV_H, p2];
                     }
                }
            }
            return null; // No path found
        }

        // --- Solvability Check ---
        function isSolvable(boardToCheck) {
            // Create a deep copy of the board to simulate moves without affecting the actual game board
            let tempBoard = JSON.parse(JSON.stringify(boardToCheck));
            let currentTiles = [];

            // Get all non-empty tiles from the game area (excluding border)
            for (let r_idx = 1; r_idx <= GAME_ROWS; r_idx++) {
                for (let c_idx = 1; c_idx <= GAME_COLS; c_idx++) {
                    if (tempBoard[r_idx][c_idx] !== EMPTY_TILE) {
                        currentTiles.push({ r: r_idx, c: c_idx, type: tempBoard[r_idx][c_idx] });
                    }
                }
            }

            if (currentTiles.length === 0) return true; // Board is already empty, thus solvable

            // Try to find and remove pairs until no more moves can be made or all tiles are cleared
            while (true) {
                let madeAMove = false;
                if (currentTiles.length === 0) return true; // All tiles cleared

                // Iterate through all possible pairs of remaining tiles
                for (let i = 0; i < currentTiles.length; i++) {
                    for (let j = i + 1; j < currentTiles.length; j++) {
                        const p1 = currentTiles[i];
                        const p2 = currentTiles[j];

                        if (p1.type === p2.type) { // Check if tiles are of the same type
                            const path = findPathOnBoard(p1, p2, tempBoard); // Use the tempBoard for pathfinding
                            if (path) {
                                // If a path is found, remove these tiles from the tempBoard
                                tempBoard[p1.r][p1.c] = EMPTY_TILE;
                                tempBoard[p2.r][p2.c] = EMPTY_TILE;
                                madeAMove = true;
                                // Remove tiles from currentTiles list (splice from the end first to avoid index issues)
                                currentTiles.splice(j, 1); 
                                currentTiles.splice(i, 1);
                                break; // Break inner loop to re-evaluate from the start of currentTiles
                            }
                        }
                    }
                    if (madeAMove) break; // Break outer loop if a move was made
                }
                if (!madeAMove) return false; // No more moves possible, but tiles remain
            }
        }


        // --- Game Logic ---
        function initGame() {
            console.log("Initializing game...");
            stopTimer();
            isProcessingMatch = false; 
            
            // Handle BGM based on user preference and game start
            if (bgmAudioElement) {
                if (bgmEnabled) {
                    console.log("initGame: BGM is enabled. Requesting restart.");
                    playMp3BGM(true); // Restart BGM for new game if enabled
                } else if (!bgmAudioElement.paused) { // If BGM is disabled but was playing (e.g. from previous state)
                    console.log("initGame: BGM is disabled but was playing. Stopping it.");
                    stopMp3BGM();
                }
            }
            updateBGMButton(); // Ensure button text reflects current BGM state

            score = 0; time = 0; tilesRemaining = GAME_ROWS * GAME_COLS;
            updateScoreDisplay(); updateTimeDisplay(); updateTilesRemainingDisplay();
            selectedTile = null; clearPathCanvas();

            let generatedBoardCandidate, solvable = false, retries = 0; const MAX_RETRIES = 100;
            console.log("Attempting to generate a solvable board...");
            do {
                let tilesToPlace = []; const numPairs = (GAME_ROWS * GAME_COLS) / 2;
                if (EMOJIS_POOL.length < numPairs) { console.error("Not enough emojis!"); showMessage("错误：表情符号不足！"); return; }
                
                // Shuffle EMOJIS_POOL and pick numPairs
                const shuffledEmojis = [...EMOJIS_POOL].sort(() => 0.5 - Math.random());
                const gameEmojis = shuffledEmojis.slice(0, numPairs);

                for (let i = 0; i < numPairs; i++) tilesToPlace.push(gameEmojis[i], gameEmojis[i]);
                // Shuffle tilesToPlace (Fisher-Yates shuffle)
                for (let i = tilesToPlace.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1));[tilesToPlace[i], tilesToPlace[j]] = [tilesToPlace[j], tilesToPlace[i]]; }
                
                generatedBoardCandidate = Array(BOARD_ROWS).fill(null).map(() => Array(BOARD_COLS).fill(EMPTY_TILE));
                let tileIndex = 0; 
                for (let r = 1; r <= GAME_ROWS; r++) { // Place tiles only in the game area (not border)
                    for (let c = 1; c <= GAME_COLS; c++) {
                        generatedBoardCandidate[r][c] = tilesToPlace[tileIndex++];
                    }
                }
                solvable = isSolvable(generatedBoardCandidate); 
                retries++;
                if(solvable) console.log(`Solvable board found after ${retries} retries.`); else if (retries % 20 === 0) console.log(`Retry ${retries}... still searching for a solvable board.`);
            } while (!solvable && retries < MAX_RETRIES);

            if (!solvable) { 
                console.warn(`Could not generate solvable board after ${MAX_RETRIES} retries. The game might be very hard or impossible.`);
                showMessage("警告：棋盘可能无解。请尝试新游戏。"); 
                // Fallback: use the last generated board even if not proven solvable, or implement a simpler generation.
            }
            board = generatedBoardCandidate; 
            renderBoard(); 
            startTimer(); 
            console.log("Game initialized.");
        }

        function renderBoard() {
            gameBoardElement.innerHTML = ''; // Clear previous board
            // Resize canvas after board elements are in DOM and sized
            setTimeout(() => { // Delay to allow layout to settle
                const boardRect = gameBoardElement.getBoundingClientRect();
                if (boardRect.width > 0 && boardRect.height > 0) {
                    const computedStyle = getComputedStyle(gameBoardElement);
                    // Calculate canvas size based on game board's content area (excluding padding)
                    lineCanvas.width = boardRect.width - (parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight));
                    lineCanvas.height = boardRect.height - (parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom));
                    canvasCtx.lineWidth = 3; // Line thickness for path
                    canvasCtx.strokeStyle = 'rgba(255, 0, 150, 0.7)'; // Bright pink for path
                } else {
                    console.warn("Game board rect has no dimensions, canvas not sized.");
                }
            }, 50); // Small delay

            // Create and append tile elements
            for (let r = 1; r <= GAME_ROWS; r++) { // Iterate through game area, not padded board
                for (let c = 1; c <= GAME_COLS; c++) {
                    const tileElement = document.createElement('div');
                    tileElement.classList.add('tile');
                    tileElement.dataset.r = r; // Store actual game row (1-indexed)
                    tileElement.dataset.c = c; // Store actual game col (1-indexed)

                    if (board[r][c] === EMPTY_TILE) {
                        tileElement.classList.add('empty');
                    } else {
                        tileElement.textContent = board[r][c];
                        tileElement.addEventListener('click', handleTileClick);
                        // Add touchstart for mobile, prevent default to avoid zoom/scroll interference, but ensure click still fires
                        tileElement.addEventListener('touchstart', (e) => { e.preventDefault(); handleTileClick(e); }, { passive: false });
                    }
                    gameBoardElement.appendChild(tileElement);
                }
            }
        }

        function handleTileClick(event) {
            if (isProcessingMatch) return; // Don't process clicks if a match is animating
            playClickSound();

            const clickedElement = event.currentTarget; // Use currentTarget for delegated events if any
            if (clickedElement.classList.contains('empty') || clickedElement.classList.contains('disappearing')) return;

            const r = parseInt(clickedElement.dataset.r);
            const c = parseInt(clickedElement.dataset.c);

            // If clicking the same selected tile, deselect it
            if (selectedTile && selectedTile.r === r && selectedTile.c === c) {
                clickedElement.classList.remove('selected');
                selectedTile = null;
                return;
            }
            clickedElement.classList.add('selected');

            if (!selectedTile) { // First tile selected
                selectedTile = { r, c, element: clickedElement, type: board[r][c] };
            } else { // Second tile selected, attempt to match
                const currentClickedTile = { r, c, element: clickedElement, type: board[r][c] };
                isProcessingMatch = true; // Lock input

                // Store references before selectedTile is cleared
                const firstTileType = selectedTile.type; 
                const firstTileElementForEffects = selectedTile.element; 

                if (firstTileType === currentClickedTile.type) { // Types match, check path
                    const path = findPathOnBoard(selectedTile, currentClickedTile, board); // Use current board state
                    if (path) { // Valid match!
                        playMatchSound();
                        drawPath(path);

                        const firstTileToRemove = selectedTile.element; 
                        const secondTileToRemove = currentClickedTile.element;
                        const r1 = selectedTile.r, c1 = selectedTile.c;
                        const r2 = currentClickedTile.r, c2 = currentClickedTile.c;

                        // Add disappearing animation class
                        firstTileToRemove.classList.add('disappearing');
                        secondTileToRemove.classList.add('disappearing');
                        firstTileToRemove.classList.remove('selected'); // Remove selection style
                        secondTileToRemove.classList.remove('selected');

                        let animationsCompleted = 0;
                        const onAnimationEnd = () => {
                            animationsCompleted++;
                            if (animationsCompleted === 2) { // Both animations finished
                                board[r1][c1] = EMPTY_TILE; // Update game state
                                board[r2][c2] = EMPTY_TILE;

                                [firstTileToRemove, secondTileToRemove].forEach(el => {
                                    el.innerHTML = ''; // Clear content
                                    el.classList.add('empty'); // Mark as empty visually
                                    el.classList.remove('disappearing'); // Clean up animation class
                                    el.removeEventListener('click', handleTileClick); // Make unclickable
                                    el.removeEventListener('touchstart', handleTileClick);
                                });

                                score += 10;
                                tilesRemaining -= 2;
                                updateScoreDisplay();
                                updateTilesRemainingDisplay();

                                setTimeout(() => clearPathCanvas(), 50); // Clear path after a brief moment

                                if (tilesRemaining === 0) { // Game Won!
                                    stopTimer();
                                    if(bgmEnabled) stopMp3BGM(); // Stop BGM on win if it was on
                                    playWinSound();
                                    showMessage(`恭喜！你赢了！得分: ${score}, 时间: ${time} 秒`);
                                }
                                isProcessingMatch = false; // Unlock input
                            }
                        };
                        firstTileToRemove.addEventListener('animationend', onAnimationEnd, { once: true });
                        secondTileToRemove.addEventListener('animationend', onAnimationEnd, { once: true });

                    } else { // Types match, but no path - "shake" effect
                        if (firstTileElementForEffects) { 
                           firstTileElementForEffects.classList.add('shaking');
                        } else {
                            // This case should ideally not happen if selectedTile is always set
                            console.error("selectedTile.element was null before shaking (same type). selectedTile:", selectedTile);
                        }
                        currentClickedTile.element.classList.add('shaking');
                        if ('vibrate' in navigator) navigator.vibrate(150); // Haptic feedback

                        // Store elements for timeout to avoid issues if selectedTile changes
                        const firstElTimeout = firstTileElementForEffects; 
                        const secondElTimeout = currentClickedTile.element; 

                        setTimeout(() => {
                            if (firstElTimeout) firstElTimeout.classList.remove('selected', 'shaking');
                            if (secondElTimeout) secondElTimeout.classList.remove('selected', 'shaking');
                            isProcessingMatch = false; // Unlock input
                        }, 500); // Duration of shake animation
                    }
                } else { // Types don't match - "shake" effect
                     if (firstTileElementForEffects) { 
                        firstTileElementForEffects.classList.add('shaking');
                     } else {
                        console.error("selectedTile.element was null before shaking (different types). selectedTile:", selectedTile);
                     }
                    currentClickedTile.element.classList.add('shaking');
                    if ('vibrate' in navigator) navigator.vibrate(150);
                    
                    const firstElTimeout_diff = firstTileElementForEffects; 
                    const secondElTimeout_diff = currentClickedTile.element; 

                    setTimeout(() => {
                        if (firstElTimeout_diff) firstElTimeout_diff.classList.remove('selected', 'shaking');
                        if (secondElTimeout_diff) secondElTimeout_diff.classList.remove('selected', 'shaking');
                        isProcessingMatch = false; // Unlock input
                    }, 500);
                }
                selectedTile = null; // Reset selection after attempting a match
            }
        }

        function drawPath(pathPoints) {
            if (!pathPoints || pathPoints.length < 2) return;
            clearPathCanvas(); // Clear previous path
            // Ensure first tile element exists to get dimensions
            const firstTileElement = gameBoardElement.querySelector(`.tile[data-r="${pathPoints[0].r}"][data-c="${pathPoints[0].c}"]`);
            if (!firstTileElement) { console.error("Cannot find first tile for path drawing, path drawing skipped."); return; }

            const tileWidth = firstTileElement.offsetWidth;
            const tileHeight = firstTileElement.offsetHeight;
            const gameBoardStyle = getComputedStyle(gameBoardElement);
            const gap = parseFloat(gameBoardStyle.getPropertyValue('gap')) || (gameBoardElement.offsetWidth > 400 ? 4 : 2); // Use actual gap

            canvasCtx.beginPath();
            for (let i = 0; i < pathPoints.length; i++) {
                const point = pathPoints[i];
                // Calculate center of the tile on the game board (1-indexed to 0-indexed for calculation)
                // The path points (p1, p2, etc.) are relative to the BOARD (with padding),
                // but tiles are rendered from 1 to GAME_ROWS/COLS.
                // The canvas is positioned over the game board's tile area.
                // So, if point.r/c is 1 (outermost actual tile), its 0-indexed position for drawing is 0.
                const x = (point.c - 1) * (tileWidth + gap) + tileWidth / 2;
                const y = (point.r - 1) * (tileHeight + gap) + tileHeight / 2;
                if (i === 0) canvasCtx.moveTo(x, y);
                else canvasCtx.lineTo(x, y);
            }
            canvasCtx.stroke();
        }

        function clearPathCanvas() {
            if (lineCanvas.width > 0 && lineCanvas.height > 0) { // Only clear if canvas has dimensions
                canvasCtx.clearRect(0, 0, lineCanvas.width, lineCanvas.height);
            }
        }

        function updateScoreDisplay() { scoreElement.textContent = score; }
        function updateTimeDisplay() { timeElement.textContent = time; }
        function updateTilesRemainingDisplay() { tilesRemainingElement.textContent = tilesRemaining; }

        function startTimer() {
            stopTimer(); // Clear any existing timer
            timerInterval = setInterval(() => {
                time++;
                updateTimeDisplay();
            }, 1000);
        }
        function stopTimer() { clearInterval(timerInterval); }

        function showMessage(message) {
            messageText.textContent = message;
            messageBox.classList.remove('hidden');
        }
        messageOkBtn.addEventListener('click', () => {
            messageBox.classList.add('hidden');
        });

        newGameBtn.addEventListener('click', initGame);

        // --- Handle PWA Visibility Change (NEW CODE) ---
        function handleVisibilityChange() {
            if (!bgmAudioElement) return; // BGM element not found

            if (document.hidden) {
                // Page is hidden (minimized, screen off, tab switched)
                if (bgmEnabled && !bgmAudioElement.paused) { // If BGM is supposed to be playing
                    console.log("Visibility changed to hidden. Pausing BGM.");
                    stopMp3BGM();
                } else {
                    console.log("Visibility changed to hidden. BGM was already paused or disabled by user.");
                }
            } else {
                // Page is visible again
                if (bgmEnabled && bgmAudioElement.paused) { // If BGM is supposed to be playing and was paused (e.g., by becoming hidden)
                    console.log("Visibility changed to visible. Attempting to resume BGM.");
                    playMp3BGM(); // This will try to play, respecting autoplay policies
                } else {
                     console.log("Visibility changed to visible. BGM is already playing or disabled by user.");
                }
            }
        }
        document.addEventListener('visibilitychange', handleVisibilityChange);
        // --- End of NEW CODE for Visibility Change ---

        window.addEventListener('resize', () => {
            // Only resize canvas if game board has children (i.e., game is active)
            if (gameBoardElement.children.length > 0) { 
                setTimeout(() => { // Delay to allow layout to settle after resize
                    const boardRect = gameBoardElement.getBoundingClientRect();
                     if (boardRect.width > 0 && boardRect.height > 0) {
                        const computedStyle = getComputedStyle(gameBoardElement);
                        lineCanvas.width = boardRect.width - (parseFloat(computedStyle.paddingLeft) + parseFloat(computedStyle.paddingRight));
                        lineCanvas.height = boardRect.height - (parseFloat(computedStyle.paddingTop) + parseFloat(computedStyle.paddingBottom));
                        clearPathCanvas(); // Clear any existing path, it will be redrawn if needed
                        // If a path was being displayed, it would need to be redrawn here.
                        // For simplicity, current implementation clears it. A more complex game might store and redraw.
                    }
                }, 100);
            }
        });

        // Service Worker Registration (for PWA functionality)
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('./sw.js') // Ensure sw.js is in the correct path
                    .then(registration => {
                        console.log('ServiceWorker registered successfully with scope: ', registration.scope);
                    })
                    .catch(error => {
                        console.log('ServiceWorker registration failed: ', error);
                    });
            });
        }

        // Initial Setup
        updateBGMButton(); // Set initial button text
        initGame(); // Start the first game
    </script>
</body>
</html>